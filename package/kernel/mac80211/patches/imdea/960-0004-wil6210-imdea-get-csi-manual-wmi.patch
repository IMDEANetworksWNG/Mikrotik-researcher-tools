diff -rupN a/drivers/net/wireless/ath/wil6210/cfg80211.c b/drivers/net/wireless/ath/wil6210/cfg80211.c
--- a/drivers/net/wireless/ath/wil6210/cfg80211.c	2019-02-15 20:40:00.000000000 +0100
+++ b/drivers/net/wireless/ath/wil6210/cfg80211.c	2021-03-18 15:07:22.622414009 +0100
@@ -122,6 +122,8 @@ enum qca_nl80211_vendor_subcmds {
 	QCA_NL80211_VENDOR_SUBCMD_DMG_RF_SET_SECTOR_CFG = 140,
 	QCA_NL80211_VENDOR_SUBCMD_DMG_RF_GET_SELECTED_SECTOR = 141,
 	QCA_NL80211_VENDOR_SUBCMD_DMG_RF_SET_SELECTED_SECTOR = 142,
+	QCA_NL80211_VENDOR_SUBCMD_GET_AOA_MEASUREMENTS = 147,
+	QCA_NL80211_VENDOR_SUBCMD_MANUAL_CONNECT = 148,
 };
 
 static int wil_rf_sector_get_cfg(struct wiphy *wiphy,
@@ -136,6 +138,15 @@ static int wil_rf_sector_get_selected(st
 static int wil_rf_sector_set_selected(struct wiphy *wiphy,
 				      struct wireless_dev *wdev,
 				      const void *data, int data_len);
+// AoA Measurements
+static int wil_get_aoa_measurements(struct wiphy *wiphy,
+                                    struct wireless_dev *wdev,
+                                    const void *data, int data_len);
+
+// Manual connect
+static int wil_manual_connect(struct wiphy *wiphy,
+                                    struct wireless_dev *wdev,
+                                    const void *data, int data_len);
 
 /* vendor specific commands */
 static const struct wiphy_vendor_command wil_nl80211_vendor_commands[] = {
@@ -169,6 +180,24 @@ static const struct wiphy_vendor_command
 			 WIPHY_VENDOR_CMD_NEED_RUNNING,
 		.doit = wil_rf_sector_set_selected
 	},
+
+    {
+        .info.vendor_id = QCA_NL80211_VENDOR_ID,
+        .info.subcmd =
+            QCA_NL80211_VENDOR_SUBCMD_GET_AOA_MEASUREMENTS,
+        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+             WIPHY_VENDOR_CMD_NEED_RUNNING,
+        .doit = wil_get_aoa_measurements
+    },
+
+    {
+        .info.vendor_id = QCA_NL80211_VENDOR_ID,
+        .info.subcmd =
+            QCA_NL80211_VENDOR_SUBCMD_MANUAL_CONNECT,
+        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+             WIPHY_VENDOR_CMD_NEED_RUNNING,
+        .doit = wil_manual_connect
+    },
 };
 
 static struct ieee80211_supported_band wil_band_60ghz = {
@@ -2710,3 +2739,165 @@ static int wil_rf_sector_set_selected(st
 
 	return rc;
 }
+
+static int wil_get_aoa_measurements(struct wiphy *wiphy,
+                                    struct wireless_dev *wdev,
+                                    const void *data, int data_len)
+{
+    struct wil6210_priv *wil = wdev_to_wil(wdev);
+	struct wil6210_vif *vif = wdev_to_vif(wil, wdev);
+
+
+	// Check the event queue
+	/*struct pending_wmi_event *evt, *t;
+	u8 queued_events;
+	queued_events = 0;
+
+	list_for_each_entry_safe(evt, t, &wil->pending_wmi_ev, list) {
+
+		queued_events++;
+	}
+
+	printk(KERN_CONT "Events pending: %d\n", queued_events);
+	*/
+
+    int rc;
+    u8 i;
+    u16 value;
+    u8 *new_data = (u8 *) data;
+    u8 channel, aoa_meas_type;
+    u32 meas_rf_mask;
+    struct wmi_aoa_meas_cmd cmd;
+    struct {
+        struct wmi_cmd_hdr wmi;
+        struct wmi_aoa_meas_event evt;
+    } __packed reply;
+    struct timeval tv;
+    u8 *meas_data;
+
+    memset(&cmd, 0, sizeof(cmd));
+
+    memcpy(&channel, new_data, sizeof(u8));
+    new_data += sizeof(u8);
+
+    memcpy(&aoa_meas_type, new_data, sizeof(u8));
+    new_data += sizeof(u8);
+
+    memcpy(&meas_rf_mask, new_data, sizeof(u32));
+    new_data += sizeof(u32);
+
+    ether_addr_copy(cmd.mac_addr, new_data);
+
+    cmd.channel = channel;
+    cmd.aoa_meas_type = aoa_meas_type;
+    cmd.meas_rf_mask = cpu_to_le32(meas_rf_mask);
+
+    memset(&reply, 0, sizeof(reply));
+    rc = wmi_call(wil, WMI_AOA_MEAS_CMDID, vif->mid,
+                  &cmd, sizeof(cmd),
+                  WMI_AOA_MEAS_EVENTID,
+                  &reply, sizeof(reply),
+                  500);
+
+    do_gettimeofday(&tv);
+    printk(KERN_INFO "wil6210-aoa$%d,%ld.%06ld,%pM,%u,%u,%d,%u,%u",
+            rc,
+            tv.tv_sec, tv.tv_usec,
+            reply.evt.mac_addr,
+            reply.evt.channel,
+            reply.evt.aoa_meas_type,
+            reply.evt.meas_rf_mask,
+            reply.evt.meas_status,
+            reply.evt.length);
+
+    meas_data = reply.evt.meas_data;
+
+    if (reply.evt.length > 0)
+    {
+        // Print phase information
+        for (i = 0 ; i < 32; i++)
+        {
+            memcpy(&value, meas_data, sizeof(u16));
+            meas_data = meas_data + 2;
+            printk(KERN_CONT ",%d", value);
+        }
+        // Print amplitude information
+        if (reply.evt.aoa_meas_type == WMI_AOA_PHASE_AMP_MEAS)
+        {
+            for (i = 0 ; i < 32; i++)
+            {
+                memcpy(&value, meas_data, sizeof(u16));
+                meas_data = meas_data + 2;
+                printk(KERN_CONT ",%d", value);
+            }
+        }
+    }
+    printk(KERN_CONT "\n");
+
+    return rc;
+}
+
+static int wil_manual_connect(struct wiphy *wiphy,
+                                    struct wireless_dev *wdev,
+                                    const void *data, int data_len)
+{
+    struct wil6210_priv *wil = wdev_to_wil(wdev);
+	struct wil6210_vif *vif = wdev_to_vif(wil, wdev);
+	struct net_device *ndev = vif_to_ndev(vif);
+	struct cfg80211_bss *bss;
+
+	u8 *new_data = (u8 *) data;
+
+	bss = cfg80211_get_bss(wiphy, 2, new_data,
+			       "Mikrotik", 8,
+			       WMI_NETTYPE_INFRA, IEEE80211_PRIVACY_ANY);
+	if (!bss) {
+		wil_err(wil, "Unable to find BSS\n");
+		return -ENOENT;
+	}
+
+    int rc;
+
+	struct wmi_connect_cmd conn;
+
+	/* WMI_CONNECT_CMD */
+	memset(&conn, 0, sizeof(conn));
+
+	// Normal connection
+	conn.network_type = WMI_NETTYPE_INFRA;
+
+	// Insecure connection
+	conn.dot11_auth_mode = WMI_AUTH11_OPEN;
+	conn.auth_mode = WMI_AUTH_NONE;
+
+
+	conn.ssid_len = 8;
+	memcpy(conn.ssid, "Mikrotik", conn.ssid_len);
+
+	// Channel 2 60.48
+	conn.channel = 2;
+
+	// The MAC address
+	ether_addr_copy(conn.bssid, new_data);
+	ether_addr_copy(conn.dst_mac, new_data);
+
+	set_bit(wil_vif_fwconnecting, vif->status);
+
+	rc = wmi_send(wil, WMI_CONNECT_CMDID, vif->mid, &conn, sizeof(conn));
+	if (rc == 0) {
+		netif_carrier_on(ndev);
+		if (!wil_has_other_active_ifaces(wil, ndev, false, true))
+			wil6210_bus_request(wil, WIL_MAX_BUS_REQUEST_KBPS);
+		vif->bss = bss;
+		/* Connect can take lots of time */
+		mod_timer(&vif->connect_timer,
+			  jiffies + msecs_to_jiffies(5000));
+	} else {
+		clear_bit(wil_vif_fwconnecting, vif->status);
+	}
+
+ out:
+	cfg80211_put_bss(wiphy, bss);
+
+    return rc;
+}
\ No newline at end of file
diff -rupN a/drivers/net/wireless/ath/wil6210/wmi.c b/drivers/net/wireless/ath/wil6210/wmi.c
--- a/drivers/net/wireless/ath/wil6210/wmi.c	2019-02-15 20:40:00.000000000 +0100
+++ b/drivers/net/wireless/ath/wil6210/wmi.c	2021-03-02 16:28:28.349286460 +0100
@@ -1502,6 +1502,7 @@ static const struct {
  */
 void wmi_recv_cmd(struct wil6210_priv *wil)
 {
+
 	struct wil6210_mbox_ring_desc d_tail;
 	struct wil6210_mbox_hdr hdr;
 	struct wil6210_mbox_ring *r = &wil->mbox_ctl.rx;
@@ -1512,6 +1513,19 @@ void wmi_recv_cmd(struct wil6210_priv *w
 	unsigned n;
 	unsigned int num_immed_reply = 0;
 
+	// Gef: Check the event queue
+	/*struct pending_wmi_event *t;
+	u8 queued_events;
+	queued_events = 0;
+
+	list_for_each_entry_safe(evt, t, &wil->pending_wmi_ev, list) {
+
+		queued_events++;
+	}
+
+	printk(KERN_CONT "[wmi.c] Events pending: %d\n", queued_events);
+	*/
+
 	if (!test_bit(wil_status_mbox_ready, wil->status)) {
 		wil_err(wil, "Reset in progress. Cannot handle WMI event\n");
 		return;
@@ -2827,10 +2841,11 @@ static void wmi_event_handle(struct wil6
 		}
 		/* unsolicited event */
 		/* search for handler */
-		if (!wmi_evt_call_handler(vif, id, evt_data,
+		wmi_evt_call_handler(vif, id, evt_data, len - sizeof(*wmi));
+		/*if (!wmi_evt_call_handler(vif, id, evt_data,
 					  len - sizeof(*wmi))) {
 			wil_info(wil, "Unhandled event 0x%04x\n", id);
-		}
+		}*/
 	} else {
 		wil_err(wil, "Unknown event type\n");
 		print_hex_dump(KERN_ERR, "evt?? ", DUMP_PREFIX_OFFSET, 16, 1,
